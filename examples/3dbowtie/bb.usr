c-----------------------------------------------------------------------
c
c  USER SPECIFIED ROUTINES:
c
c     - boundary conditions
c     - initial conditions
c     - variable properties
c     - forcing function for fluid (f)
c     - forcing function for passive scalar (q)
c     - general purpose routine for checking errors etc.
c
c-----------------------------------------------------------------------
      subroutine usersrc(baseidx,srchx,srchy,srchz,srcex,srcey,srcez)

      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'
      include 'PML'

      ! Add source terms to the fields given in src{e,h}{x,y,z}.
      ! Read file doc/rea-file.txt for specification.
      ! Since we want to make it possible to have several sources,
      ! we specify a `baseidx', relative to which all parameters are
      ! read.

      integer baseidx

      real srchx(lx1,ly1,lz1,lelt),
     $     srchy(lx1,ly1,lz1,lelt),
     $     srchz(lx1,ly1,lz1,lelt),
     $     srcex(lx1,ly1,lz1,lelt),
     $     srcey(lx1,ly1,lz1,lelt),
     $     srcez(lx1,ly1,lz1,lelt)

      ! temporary storage for source field
      real mysrc(lx1,ly1,lz1,lelt)

      ! Extent of domain
      integer n
      save n
      real xsize, ysize, zsize
      save xsize, ysize, zsize
      real xmin, xmax, ymin, ymax, zmin, zmax
      save xmin, xmax, ymin, ymax, zmin, zmax

      ! Helper for initialize-once variables
      logical icalld
      save    icalld
      data    icalld  /.false./

      ! Time modulation
      real tstart, tstop
      real tmodtyp
      real tfactor

      ! Spatial modulation
      real smodtyp
      integer fldchs
      real x, y, z
      real gauss_x, gauss_y, gauss_z
      real fldhere
      real rk, rw, xx, rd 
      integer bitpatt


      ! APS source help variables
      real r, phi, bunchz, aziexp
      integer aziidx

      ! Loop variables
      integer i, el

      ! One-time initialization
      if (.not.icalld) then
        icalld = .true.

        n = nx1*ny1*nz1*nelt

        xmin = glmin(xm1,n)
        xmax = glmax(xm1,n)
        ymin = glmin(ym1,n)
        ymax = glmax(ym1,n)
        zmin = glmin(zm1,n)
        zmax = glmax(zm1,n)

        xsize = xmax-xmin
        ysize = ymax-ymin
        zsize = zmax-zmin
      endif

      ! Evaluate time modulation.
      tmodtyp = param(baseidx+0)
      tstart  = param(baseidx+5)
      tstop   = param(baseidx+6)

      if ((time.lt.tstart).or.(time.gt.tstop)) then
        return
      endif

      if     (tmodtyp.eq.0) then
        return
      elseif (tmodtyp.eq.1) then
        ! Constant 1
        tfactor = 1.

      elseif (tmodtyp.eq.2) then
        ! Gaussian pulse
        tfactor = exp(-(2*(time-param(baseidx+7))/param(baseidx+8))**2)

      elseif (tmodtyp.eq.3) then
        ! Cosine
        tfactor = cos(2*pi*param(baseidx+7)*time)

      elseif (tmodtyp.eq.4) then
        ! Rectangular pulses
        if (mod(time, param(baseidx+8)).le.param(baseidx+7)) then
          tfactor = 1.
        else
          tfactor = 0.
        endif
      elseif (tmodtyp.eq.5) then

          tfactor = param(59) 
        ! check  what to be defined here 

      else
        write (*,*) 'Invalid time modulation type', tmodtyp
        call exitt
      endif

      ! Apply global scaling.
      tfactor = tfactor * param(baseidx+2)

      ! Evaluate space modulation.
      smodtyp = param(baseidx+1)
      fldchs  = int(param(baseidx+3))

      if (smodtyp.eq.1) then
        ! Constant 1
        fldhere = 1.
        do i=1,n
          mysrc(i,1,1,1) = tfactor
        enddo
      elseif (smodtyp.eq.2) then
        ! Gaussian
        gauss_x = param(baseidx+ 9) + param(baseidx+12)*time
        gauss_y = param(baseidx+10) + param(baseidx+13)*time
        gauss_z = param(baseidx+11) + param(baseidx+14)*time

        do i=1,n
          ! where are we?
          x = xm1(i,1,1,1)
          y = ym1(i,1,1,1)
          z = zm1(i,1,1,1)

          fldhere = 1.
          if (param(baseidx+15).ne.0) fldhere = fldhere * 
     $        exp(-(2*(x-gauss_x)/param(baseidx+15))**2)
          if (param(baseidx+16).ne.0) fldhere = fldhere * 
     $        exp(-(2*(y-gauss_y)/param(baseidx+16))**2)
          if (param(baseidx+17).ne.0) fldhere = fldhere * 
     $        exp(-(2*(z-gauss_z)/param(baseidx+17))**2)

          mysrc(i,1,1,1) = tfactor * fldhere
        enddo
      elseif (smodtyp.eq.3) then
        ! Plane wave
        do i=1,n
          ! where are we?
          x = xm1(i,1,1,1)
          y = ym1(i,1,1,1)
          z = zm1(i,1,1,1)
          fldhere = cos(
     $        param(baseidx+9)*x
     $        +param(baseidx+10)*y
     $        +param(baseidx+11)*z
     $        -2*pi*param(baseidx+12)*time)
          mysrc(i,1,1,1) = tfactor * fldhere
        enddo
      elseif (smodtyp.eq.4) then
        ! APS source term
        ! cf. I. Zagorodnov, T. Weiland,
        ! TE/TM field solver for particle beam simulations without
        ! numerical Cherenkov radiation
        ! Physical Review Special Topics, Accelerators and Beams
        ! Vol. 8, 042001 (2005)
        ! Section V, Part A.

        if (param(baseidx+10).eq.0) then
          write (*,*) 'APS source: Wave speed must be nonzero.'
          call exitt
        endif

        if (param(baseidx+12).eq.0) then
          write (*,*) 'APS source: Radial sigma must be nonzero.'
          call exitt
        endif

        do i=1,n
          ! where are we?
          x = xm1(i,1,1,1)
          y = ym1(i,1,1,1)
          z = zm1(i,1,1,1)

          r = sqrt(x**2 + y**2)
          phi = atan2(y, x)
          bunchz = z/(param(baseidx+10)*cspeed)-time

          aziexp = 0.5 * param(baseidx+13)
          do aziidx=1,7
            aziexp = aziexp + cos(aziidx*phi)*param(baseidx+13+aziidx)
          enddo

          fldhere = 
     $        cspeed*param(baseidx+10)/pi/param(baseidx+11)
     $        *exp(-(2*(r-param(baseidx+11))/param(baseidx+12))**2)
     $        *aziexp

          if (param(baseidx+9).ne.0) then
            fldhere = fldhere*exp(-(2*bunchz/param(baseidx+9))**2)
          endif
          mysrc(i,1,1,1) = tfactor * fldhere
        enddo

      elseif (smodtyp.eq.5) then

        wavelength = param(69)

	rk   = 2.0*pi/wavelength  
	rw   = 2.0*pi*cspeed/wavelength       !

        time_src_stop   = tstop  
        wave_front_dist = cspeed*(time)                
	wave_end_dist   = cspeed*(time-time_src_stop)

        co = permit_0/permea_0
        co = sqrt(co) 

        do i=1,n

          ! where are we?
          x = xm1(i,1,1,1)
          y = ym1(i,1,1,1)
          z = zm1(i,1,1,1)

	  if (param(61).eq.1) xx = x-xmin !                              
          if (param(61).eq.2) xx = y-ymin
          if (param(61).eq.3) xx = z-zmin

          ! if ((xx.le.wave_front_dist).and.(xx.ge.wave_end_dist)) then

          fldhere      =    sin(rw*time-rk*xx)  ! src
          fldhere_prime= rw*cos(rw*time-rk*xx)  ! src_dt

          if (IFSCAT) then
              mysrc(i,1,1,1)= tfactor*fldhere_prime
              srcE =-(epsilo(i,1,1,1)-permit_0)*mysrc(i,1,1,1)
              srcH =-(mu    (i,1,1,1)-permea_0)*mysrc(i,1,1,1)
          else
              write(6,*) 'IFSCAT is not defined'
	      call exitt
	  endif

          if     (param(61).eq.1) then

              srchy(i,1,1,1)=srchy(i,1,1,1)+co*srcH              
              srchz(i,1,1,1)=srchz(i,1,1,1)+co*srcH              
              srcey(i,1,1,1)=srcey(i,1,1,1)+srcE              
              srcez(i,1,1,1)=srcez(i,1,1,1)+srcE             
 
              inchy(i,1,1,1)= tfactor*fldhere
              inchz(i,1,1,1)= tfactor*fldhere
              incey(i,1,1,1)= tfactor*fldhere
              incez(i,1,1,1)= tfactor*fldhere

          elseif (param(61).eq.2) then

              srchx(i,1,1,1)=srchx(i,1,1,1)+co*srcH              
              srchz(i,1,1,1)=srchz(i,1,1,1)+co*srcH              
              srcex(i,1,1,1)=srcex(i,1,1,1)+srcE              
              srcez(i,1,1,1)=srcez(i,1,1,1)+srcE             

              inchx(i,1,1,1)=tfactor*fldhere
              inchz(i,1,1,1)=tfactor*fldhere
              incex(i,1,1,1)=tfactor*fldhere
              incez(i,1,1,1)=tfactor*fldhere

          elseif (param(61).eq.3) then

              srchx(i,1,1,1)=srchx(i,1,1,1)+co*srcH              
              srchy(i,1,1,1)=srchy(i,1,1,1)+co*srcH              
              srcex(i,1,1,1)=srcex(i,1,1,1)+srcE              
              srcey(i,1,1,1)=srcey(i,1,1,1)+srcE              

              inchx(i,1,1,1)=tfactor*fldhere
              inchy(i,1,1,1)=tfactor*fldhere
              incex(i,1,1,1)=tfactor*fldhere
              incey(i,1,1,1)=tfactor*fldhere

          else
              write(6,*) 'Direction :: not defined in param(61)'
	      call exitt
	  endif

        enddo

      else
        write (*,*) 'Invalid spatial modulation type', smodtyp
        call exitt
      endif

      return
      end
c-----------------------------------------------------------------------
      subroutine userini(tt, myhx, myhy, myhz, myex, myey, myez)
c-----------------------------------------------------------------------
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'

      real tt
      real myhx(lx1,ly1,lz1,lelt)
      real myhy(lx1,ly1,lz1,lelt)
      real myhz(lx1,ly1,lz1,lelt)
      real myex(lx1,ly1,lz1,lelt)
      real myey(lx1,ly1,lz1,lelt)
      real myez(lx1,ly1,lz1,lelt)

      do i=1,nx1*ny1*nz1*nelt
        xx=XM1(i,1,1,1)
        yy=YM1(i,1,1,1)
        zz=ZM1(i,1,1,1)

        myhx(i,1,1,1) = 0
        myhy(i,1,1,1) = 0
        myhz(i,1,1,1) = 0
        myex(i,1,1,1) = 0
        myey(i,1,1,1) = 0
        myez(i,1,1,1) = 0
      enddo

      return
      end

c-----------------------------------------------------------------------
      subroutine uservp (ix,iy,iz,ielg)

      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'

      integer  n, ix, iy, iz, iel, ielg
      real     pi, one, xcc, ycc, zcc, x1, y1, z1
      real     lambda, fc, wc                     

      iel = gllel(ielg)

      call usermedia (ix,iy,iz,iel)

      if (IFDRUDE)  call userdrude (ix,iy,iz,iel)

      return
      end

c-----------------------------------------------------------------------

      subroutine usermedia(ix,iy,iz,ielg) ! Vector form of userf

      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'

      integer  n, ix, iy,iz, ielg
      real     pi, one, xcc, ycc, zcc, x1, y1, z1
      real     lambda, fc, wc                     

      udiff  = 0.
      utrans = 0.

      permea = permea_0             
      permit = permit_0                

      return
      end

c-----------------------------------------------------------------------
      subroutine userdrude(ix,iy,iz,iel) ! Vector form of userf

      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'

      integer  n, ix, iy,iz, iel
      real     pi, one, xcc, ycc, zcc, x1, y1, z1
      real     rr, r2                                      
      real     permit_0, permea_0, permit_r
      real     gamma_p, freq_p, lambda, fc, wc                     

      xx  = xm1(ix,iy,iz,iel)
      yy  = ym1(ix,iy,iz,iel)
      zz  = zm1(ix,iy,iz,iel)


      permit   = permit_0
      permea   = permea_0
      drude_alpha = 0.0               
      drude_beta  = 0.0                         

c     Vertices for Triangle 1 (vx1,vy1), (vx2,vy2), vx3,vy3) 
       vx1= 50.0
       vy1= 0.0
       vx2= 400.0
       vy2= 175.0
       vx3= 400.0
       vy3=-175.0

c     Vertices for Triangle 2 (wx1,wy1), (wx2,wy2), wx3,wy3) 
       wx1=-50.0
       wy1=-0.0
       wx2=-400.0
       wy2= 175.0 
       wx3=-400.0
       wy3=-175.0

       vx1=vx1*nmscale
       vx2=vx2*nmscale
       vx3=vx3*nmscale
       vy1=vy1*nmscale
       vy2=vy2*nmscale
       vy3=vy3*nmscale

       wx1=wx1*nmscale
       wx2=wx2*nmscale 
       wx3=wx3*nmscale
       wy1=wy1*nmscale
       wy2=wy2*nmscale
       wy3=wy3*nmscale

       
       t1=(vy2-vy1)/(vx2-vx1)*(xx-vx1)+vy1
       t2=(vy3-vy1)/(vx3-vx1)*(xx-vx1)+vy1

       s1=(wy2-wy1)/(wx2-wx1)*(xx-wx1)+wy1
       s2=(wy3-wy1)/(wx3-wx1)*(xx-wx1)+wy1

       z1= -25.0*nmscale
       z2=  25.0*nmscale

       if ((zz.ge.z1).and.(zz.le.z2)) then

       if      ( (yy.ge.t2).and.(yy.le.t1)) then

           if (xx.le.vx3) then 

           permit      = permit_0*permit_r
           permea      = permea_0 
           drude_alpha =-gamma_p
           drude_beta  = permit_0*freq_p**2        

           endif

       elseif  ( (yy.ge.s2).and.(yy.le.s1)) then

           if (xx.ge.wx3) then 

           permit      = permit_0*permit_r
           permea      = permea_0 
           drude_alpha =-gamma_p
           drude_beta  = permit_0*freq_p**2        

           endif
       endif

       endif

       return
       end

c-----------------------------------------------------------------------

      subroutine userbfv(bffx,bffy,bffz) ! Vector form of userf
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'

      real bffx(lx1,ly1,lz1,lelt)
     $   , bffy(lx1,ly1,lz1,lelt) 
     $   , bffz(lx1,ly1,lz1,lelt)

      common /usrfvc/ fscale(lx1*ly1*lz1*lelt)
      common /srcinfo/ src_loc, src_lambda

      integer  mm
      real     lambda,fc,wc,width,half,tc
      real     arg, om, sot                       

      integer icalld
      save    icalld
      data    icalld  /0/
c
      n  = nx1*ny1*nz1*nelt

      if (icalld.eq.0) then

          icalld = 1

          xmin = glmin(xm1,n)
          xmax = glmax(xm1,n)
          ymin = glmin(ym1,n)
          ymax = glmax(ym1,n)
          zmin = glmin(zm1,n)
          zmax = glmax(zm1,n)

          Lxsize = xmax-xmin
          Lysize = ymax-ymin
          Lzsize = zmax-zmin

          do i=1,n

	  x = xm1(i,1,1,1)
	  y = ym1(i,1,1,1)
                                                                   
          src_loc    = param(70)*nmscale                               
          src_lambda = param(71)*nmscale                                

          if (IFNM)  then                                             

          if (param(72).eq.1) arg=-param(74)*(2*(x-src_loc)/Lxsize)**2 
          if (param(72).eq.2) arg=-param(74)*(2*(y-src_loc)/Lysize)**2 
          if (param(72).eq.3) arg=-param(74)*(2*(z-src_loc)/Lzsize)**2  

          else

          if (param(72).eq.1) arg=-param(74)*(2*(x-src_loc)/Lxsize)**2  
          if (param(72).eq.2) arg=-param(74)*(2*(y-src_loc)/Lysize)**2  
          if (param(72).eq.3) arg=-param(74)*(2*(z-src_loc)/Lzsize)**2  

          endif

          fscale(i) = exp(arg)        !impede(i,1,1,1)      

          if (IFNM) fscale(i) = exp(arg)*param(103)

          enddo
            
      endif
 
      om  =  2*pi*cspeed/(src_lambda)*time  ! ifscat=.false.                       
      omp =  2*pi*cspeed/(src_lambda)       ! ifscat=.true.                  

      if (time .le.  param(69)*dt) then

   
      if (IFSCAT) then    ! scattering field formulation 

         if (param(58).eq.1)  sot = -omp*sin(om)                     
         sot = -sot*(epsilo(i,1,1,1)-1.0)                          

         do i=1,n

         if (param(73).eq.1) 
     $       bffx(i,1,1,1) = bffx(i,1,1,1) + sot*fscale(i)            
         if (param(73).eq.1) 
     $       inchx(i,1,1,1) = cos(om)*fscale(i)            
         if (param(73).eq.2) 
     $       bffy(i,1,1,1) = bffy(i,1,1,1) + sot*fscale(i)
         if (param(73).eq.2) 
     $       inchy(i,1,1,1) = cos(om)*fscale(i)            
         if (param(73).eq.3) 
     $       bffz(i,1,1,1) = bffz(i,1,1,1) + sot*fscale(i)
         if (param(73).eq.3) 
     $       inchz(i,1,1,1) = cos(om)*fscale(i)            
         if (param(73).eq.4) 
     $       bffx(i,1,1,1) = bffx(i,1,1,1) + sot*fscale(i)
         if (param(73).eq.4) 
     $       incex(i,1,1,1) = cos(om)*fscale(i)            
         if (param(73).eq.5) 
     $       bffy(i,1,1,1) = bffy(i,1,1,1) + sot*fscale(i)
         if (param(73).eq.5) 
     $       incey(i,1,1,1) = cos(om)*fscale(i)            
         if (param(73).eq.6) 
     $       bffz(i,1,1,1) = bffz(i,1,1,1) + sot*fscale(i)
         if (param(73).eq.6) 
     $       incez(i,1,1,1) = cos(om)*fscale(i)            
         enddo

      else

      if (param(58).eq.1)  sot =  cos(om)                                        

      do i=1,n
         if (param(73).eq.1) 
     $       bffx(i,1,1,1) = bffx(i,1,1,1) + sot*fscale(i)            
         if (param(73).eq.2) 
     $       bffy(i,1,1,1) = bffy(i,1,1,1) + sot*fscale(i)
         if (param(73).eq.3) 
     $       bffz(i,1,1,1) = bffz(i,1,1,1) + sot*fscale(i)
         if (param(73).eq.4) 
     $       bffx(i,1,1,1) = bffx(i,1,1,1) + sot*fscale(i)
         if (param(73).eq.5) 
     $       bffy(i,1,1,1) = bffy(i,1,1,1) + sot*fscale(i)
         if (param(73).eq.6) 
     $       bffz(i,1,1,1) = bffz(i,1,1,1) + sot*fscale(i)
      enddo

      endif

      endif

      return
      end

c-----------------------------------------------------------------------
      subroutine userf  (ix,iy,iz,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      integer ix, iy, iz, ieg
C
      return
      end
c-----------------------------------------------------------------------
      subroutine userq  (ix,iy,iz,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'
C
      qvol   = 0.0
      source = 0.0

      return
      end
c-----------------------------------------------------------------------
      subroutine useric (ix,iy,iz,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'
C
      return
      end
c-----------------------------------------------------------------------
      subroutine userbc (ix,iy,iz,iside,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      ux=0.0
      uy=0.0
      uz=0.0
      temp=0.0

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat

      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'

      return
      end

c-----------------------------------------------------------------------
      subroutine usrdat2

      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'

      real     pi

      n    = nx1*ny1*nz1*nelv

c     ifxyo= .true.

      xmin = glmin(xm1,n)
      xmax = glmax(xm1,n)
      ymin = glmin(ym1,n)
      ymax = glmax(ym1,n)
      zmin = glmin(zm1,n)
      zmax = glmax(zm1,n)

c     if (nid.eq.0) write(6,*) wavenumber,' This is wavenumber'

      if (IFNM) then
          nmscale = 1e-9              ! nanoscale                                                  
          sx = nmscale
          sy = nmscale
          sz = nmscale
       else
          nmscale = 1.0 !/(xmax-xmin)   ! nanoscale                                                  
          sx = 1.0 !/(xmax-xmin)
          sy = 1.0 !/(ymax-ymin)       
          if (if3d) sz = 1.0 !/(zmax-zmin)            
      endif 

      if (if3d) then

      do i=1,n
         xm1(i,1,1,1) = sx*xm1(i,1,1,1)                
         ym1(i,1,1,1) = sy*ym1(i,1,1,1)                        
         zm1(i,1,1,1) = sz*zm1(i,1,1,1)
      enddo

      else

      do i=1,n
         xm1(i,1,1,1) = sx*xm1(i,1,1,1)               
         ym1(i,1,1,1) = sy*ym1(i,1,1,1)                        
      enddo

      endif


      return
      end


c-----------------------------------------------------------------------
      subroutine usersol(u,ind ,ii,i,j,k,e,tt)
C---------------------------------------------------------------

      INCLUDE 'SIZE'
      INCLUDE 'TOTAL'
      INCLUDE 'EMWAVE'

      real     omega, tmpH, tmpE, tt  
      real     xx, yy, zz, u    
      integer  i, j, k, e, ii, ind                 


      return
      end

c-----------------------------------------------------------------------
      subroutine userft           
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'

      return
      end

c-----------------------------------------------------------------------
      subroutine userchk    
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'

      common /ccpu/ cpu_t,cpu_t0
      common /err / errhx(lx1,ly1,lz1,lelt)
     $             ,errhy(lx1,ly1,lz1,lelt)
     $             ,errhz(lx1,ly1,lz1,lelt)
     $             ,errex(lx1,ly1,lz1,lelt)
     $             ,errey(lx1,ly1,lz1,lelt)
     $             ,errez(lx1,ly1,lz1,lelt)
      integer idt
      logical dochk

      dochk = .false.       

c ... check maximum dt for every 10 steps. 
      n    = nx1*ny1*nz1*nelt
      nsrf = nx1*nz1*nelt*6
      idt  = 10
      if (ifvardt.and.(mod(istep,idt).eq.0))     dochk=.true.    

c ... regular checks for iocomm 
      if (istep.le.10.or.mod(istep,iocomm).eq.0) dochk=.true.    

c ... compute errors
      if (dochk) then

      call rzero(shx,n) 
      call rzero(shy,n) 
      call rzero(shz,n) 
      call rzero(sex,n) 
      call rzero(sey,n) 
      call rzero(sez,n) 

      if (ifsol) call usersol(time,shx,shy,shz,sex,sey,sez)

      call sub3(errhx,shx,hx,n)         
      call sub3(errhy,shy,hy,n)         
      call sub3(errhz,shx,hz,n)         
      call sub3(errex,sex,ex,n)         
      call sub3(errey,sey,ey,n)         
      call sub3(errez,sez,ez,n)         

      HXmr = glamax(errhx,n)        
      HYmr = glamax(errhy,n)        
      HZmr = glamax(errhz,n)        
      EXmr = glamax(errex,n)        
      EYmr = glamax(errey,n)        
      EZmr = glamax(errez,n)        

      HXer = glsc3(errhx,bm1,errhx,n)/volvm1            
      HYer = glsc3(errhy,bm1,errhy,n)/volvm1            
      HZer = glsc3(errhz,bm1,errhz,n)/volvm1            
      EXer = glsc3(errex,bm1,errex,n)/volvm1            
      EYer = glsc3(errey,bm1,errey,n)/volvm1            
      EZer = glsc3(errez,bm1,errez,n)/volvm1            

      if (hxer.gt.0) hxer = sqrt(hxer)
      if (hyer.gt.0) hyer = sqrt(hyer)
      if (hzer.gt.0) hzer = sqrt(hzer)
      if (exer.gt.0) exer = sqrt(exer)
      if (eyer.gt.0) eyer = sqrt(eyer)
      if (ezer.gt.0) ezer = sqrt(ezer)

c ... compute max gap size at interfaces between elmts.

      call cem_gap                     

      HXgp = glamax(ghx,nsrf) 
      HYgp = glamax(ghy,nsrf) 
      HZgp = glamax(ghz,nsrf) 
      EXgp = glamax(gex,nsrf) 
      EYgp = glamax(gey,nsrf) 
      EZgp = glamax(gez,nsrf) 

c ... print statement

      snel= nelt + .5
      snel= sqrt(snel)
      nels= snel
      nnn = nx1-1            ! degree 
      npt1= nnn*nels
      npts= nx1*ny1*nz1*nelt ! npts = npt1**ndim

      if (nid.eq.0) then

          h2err = hxer**2 + hyer**2
          if (h2err.gt.0) h2err = sqrt(h2err)

          hmgp = max(hxgp,hygp)
          hmer = max(hxmr,hymr)

          write(6,91) ISTEP,nelt,nels,nnn,npt1,npts
     $    ,time,dt,HXer,HYer,HZer,EXer,EYer,EZer,cpu_t       
          write(6,92) ISTEP,nelt,nels,nnn,npt1,npts
     $    ,time,dt,HXmr,HYmr,HZmr,EXmr,EYmr,EZmr,cpu_t      

          if (ifvardt) then            
              dtstd= HXmr+HYmr+HZmr+EXmr+EYmr+EZmr
              dtstd= abs(dtstd)
              cntdt= 1./idtchg
              write(6,93) idtchg,cntdt
              if (dtstd.gt.fldmax) dtchk=.true.
              if (dtstd.le.fldmax) dtchk=.false.
              if (dtstd.gt.fldmax) write(6,94) fldmax      
          endif
      endif ! nid=0

      endif ! ifdochk

 91   format(/,i5,3i5,i5,i9,1p9e10.3,' CPU: L2  ')
 92   format(/,i5,3i5,i5,i9,1p9e10.3,' CPU: Linf')
 93   format('  dxmin/(cspeed*',i2,')',', s=',f5.3)      
 94   format('  Reduce DT <- maximum norm is bigger than:',e12.7)      

      return
      end
c-----------------------------------------------------------------------
