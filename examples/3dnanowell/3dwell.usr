
c-----------------------------------------------------------------------
c
c  USER SPECIFIED ROUTINES:
c
c     - boundary conditions
c     - initial conditions
c     - variable properties
c     - forcing function for fluid (f)
c     - forcing function for passive scalar (q)
c     - general purpose routine for checking errors etc.
c
c-----------------------------------------------------------------------
      subroutine usersol(tt, myshx, myshy, myshz, mysex, mysey, mysez)
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'
      include 'RK5'

      real tt
      real myshx(lx1,ly1,lz1,lelt)
      real myshy(lx1,ly1,lz1,lelt)
      real myshz(lx1,ly1,lz1,lelt)
      real mysex(lx1,ly1,lz1,lelt)
      real mysey(lx1,ly1,lz1,lelt)
      real mysez(lx1,ly1,lz1,lelt)
      real xmaxsize
      save xmaxsize

      do  i= 1,nx1*ny1*nz1*nelt
         xx= xm1(i,1,1,1)
         yy= ym1(i,1,1,1)
         zz= zm1(i,1,1,1)

       ! myshx(i,1,1,1) = 0
       ! myshy(i,1,1,1) = 0
       ! myshz(i,1,1,1) = 0
       ! mysex(i,1,1,1) = 0
       ! mysey(i,1,1,1) = 0
       ! mysez(i,1,1,1) = 0
      enddo

      return
      end
c-------------------------------------------------------------------
c The userinc subroutine specifies the incident field
c-------------------------------------------------------------------
      subroutine userinc

      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'
      include 'PML'
      include 'SCRATCH'
      include 'RK5'

      ! Add source terms to the fields given in src{e,h}{x,y,z}.
      ! Read file doc/rea-file.txt for specification.
      ! Since we want to make it possible to have several sources,
      ! we specify a `baseidx', relative to which all parameters are
      ! read.

      real    kx , ky , kz
      real    wavelength, wavenum, omega, phase
      real    impedence                 
      real    ts, tstop, E_prefactor, H_prefactor

      twopi  = 2.0*pi
      refractive_index= 1.33 ! water
      refractive_index= 1.00 ! free space (also air)
      wavelength= param(69)*nmscale      ! wavelength of incident field
      wavenum   = twopi/wavelength          ! wave number = 2pi/lambda
      kx = wavenum*refractive_index*param(66)
      ky = wavenum*refractive_index*param(67)
      kz = wavenum*refractive_index*param(68)
      omega = wavenum*cspeed              ! angular frequency
      impedence = sqrt(permea_0/permit_0) ! impedence of free space FIXME - must account for refractive_index

      ! Setup Gaussian amplitude prefactors for the incident fields
      tstop = param(40)
      ts = 3*tstop
      E_prefactor = exp(-((rktime-ts)/tstop)**2)
      H_prefactor = E_prefactor/impedence

      n = nx1*ny1*nz1*nelt
      do i= 1,n
         xx = xm1(i,1,1,1)  ! x coordinate of that point
         yy = ym1(i,1,1,1)  ! x coordinate of that point
         zz = zm1(i,1,1,1)  ! x coordinate of that point
         phase = omega*rktime-(kx*xx+ky*yy+kz*zz)                   
         sincex(i,1,1,1) = E_prefactor*cos(phase)
         sincey(i,1,1,1) = 0
         sincez(i,1,1,1) = 0
         sinchx(i,1,1,1) = 0
         sinchy(i,1,1,1) = H_prefactor*cos(phase)
         sinchz(i,1,1,1) = 0
      enddo

      ! For each point in the mesh ...
      do i= 1,n   
        xx = xm1(i,1,1,1)  ! x coordinate of that point
        yy = ym1(i,1,1,1)  ! x coordinate of that point
        zz = zm1(i,1,1,1)  ! x coordinate of that point

        ! Squelch the field to zero if it's in the PML region.
        ! If incflag = 1 the field is heading in the positive direction,
        ! and if incflag = -1 the field is heading in the negative
        ! direction.  There are PML regions at each end of the domain.

        ! FIXME - Is this really necessary?  It seems the 
        ! outpml data structure already has this info in it.  Can't we
        ! just say tfac=outpml(i,1,1,1) and skip all this?

        tfac = 0
        if     (incflag.eq.1.and.(cspeed*rktime-zz).ge.zminval) then
            tfac=outpml(i,1,1,1)  ! 1 if outside PML region, 0 if inside
        elseif (incflag.eq.-1.and.(cspeed*rktime+zz).ge.zmaxval) then
            tfac=outpml(i,1,1,1)  ! 1 if outside PML region, 0 if inside
        endif

        ! At this point, tfac = 1 (outside PML) or 0 (inside PML)
        incex(i,1,1,1)= tfac*sincex(i,1,1,1)
        incey(i,1,1,1)= tfac*sincey(i,1,1,1)
        incez(i,1,1,1)= tfac*sincez(i,1,1,1)
        inchx(i,1,1,1)= tfac*sinchx(i,1,1,1)
        inchy(i,1,1,1)= tfac*sinchy(i,1,1,1)
        inchz(i,1,1,1)= tfac*sinchz(i,1,1,1)
      enddo

      return
      end
c-----------------------------------------------------------------------
      subroutine usersrc(baseidx,srchx,srchy,srchz,srcex,srcey,srcez)

      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'
      include 'PML'
      include 'SCRATCH'

      ! Add source terms to the fields given in src{e,h}{x,y,z}.
      ! Read file doc/rea-file.txt for specification.
      ! Since we want to make it possible to have several sources,
      ! we specify a `baseidx', relative to which all parameters are
      ! read.

      integer baseidx

      real srchx(lx1,ly1,lz1,lelt),
     $     srchy(lx1,ly1,lz1,lelt),
     $     srchz(lx1,ly1,lz1,lelt),
     $     srcex(lx1,ly1,lz1,lelt),
     $     srcey(lx1,ly1,lz1,lelt),
     $     srcez(lx1,ly1,lz1,lelt)

      n= nx1*ny1*nz1*nelt

      do i = 1,nx1*ny1*nz1*nelt
         tmp= bm1(i,1,1,1)*outpml(i,1,1,1)
         srcex(i,1,1,1)=srcex(i,1,1,1)+incex(i,1,1,1)*tmp           
         srchy(i,1,1,1)=srchy(i,1,1,1)+inchy(i,1,1,1)*tmp          
      enddo

      return
      end
c-----------------------------------------------------------------------
      subroutine userini(tt, myhx, myhy, myhz, myex, myey, myez)
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'

      real tt
      real myhx(lx1,ly1,lz1,lelt)
      real myhy(lx1,ly1,lz1,lelt)
      real myhz(lx1,ly1,lz1,lelt)
      real myex(lx1,ly1,lz1,lelt)
      real myey(lx1,ly1,lz1,lelt)
      real myez(lx1,ly1,lz1,lelt)

      do i=1,nx1*ny1*nz1*nelt
        myhx(i,1,1,1) = 0
        myhy(i,1,1,1) = 0
        myhz(i,1,1,1) = 0
        myex(i,1,1,1) = 0
        myey(i,1,1,1) = 0
        myez(i,1,1,1) = 0
      enddo

      return
      end
c-----------------------------------------------------------------------
      subroutine uservp (ix,iy,iz,ielg)
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'

      integer  n, ix, iy, iz, ielg, iel
      real     pi, one, xcc, ycc, zcc, x1, y1, z1
      real     lambda, fc, wc                     

      iel=gllel(ielg)

      call usermedia   (ix,iy,iz,iel)

      if (IFDRUDE ) call userdrude (ix,iy,iz,iel)

      return
      end

c-----------------------------------------------------------------------

      subroutine usermedia(ix,iy,iz,iel) ! Vector form of userf
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'

      integer  n, ix, iy,iz, ieg
      real     pi, one, xcc, ycc, zcc, x1, y1, z1
      real     lambda, fc, wc                     

      udiff  = 0.
      utrans = 0.

      permea = permea_0             
      permit = permit_0                

      return
      end

c-----------------------------------------------------------------------
      subroutine userdrude(ix,iy,iz,iel) ! Vector form of userf

      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'

      integer  n, ix, iy,iz, iel
      real     pi, one, xcc, ycc, zcc, x1, y1, z1
      real     rr, r2, rad, rad2                                      
      real     lambda, fc, wc, n_subs
      n_subs=1.59 ! index of refraction of substrate from Jason's .ppt

      if     (if_in_region(iel).eq.0) then ! air / freespace
             permit      = permit_0
             permea      = permea_0
             drude_alpha = 0.0
             drude_beta  = 0.0

      elseif (if_in_region(iel).eq.1) then ! substrate
             permit_r    = n_subs**2
             permit      = permit_0*permit_r
             permea      = permea_0
             drude_alpha = 0.0
             drude_beta  = 0.0

      elseif (if_in_region(iel).eq.2) then ! gold
            !eV -> SI: conversion from eV to inverse seconds
             tmp =  (27.2114*2.41888e-17)
            !permit_r    = 5.398334980
            !gamma_p     = 0.068017714/tmp
            !freq_p      = 9.200688/tmp
             permit_r    = 1.0000000000
             gamma_p     = 0.23670/tmp
             freq_p      = 7.32318/tmp
             permit      = permit_0*permit_r
             permea      = permea_0
             drude_alpha =-gamma_p
             drude_beta  = permit_0*freq_p**2
            ! write(6,*) 'drude---',iel,drude_alpha,drude_beta
      else
            if (nid.eq.0) write(6,*) 'dielectric or metal:not defiened'
            call exitt
      endif

      return
      end

c-----------------------------------------------------------------------
      subroutine userpml(ix,iy,iz,iel) ! Vector form of userf
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'

      character*5 pmlside   

      n= nx1*ny1*nz1*nelt

      pmlR0 = 10.0**(-15)
      pmlM  = 2.0

      return
      end

c-----------------------------------------------------------------------
      subroutine userf  (ix,iy,iz,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      integer ix, iy, iz, ieg
C
      return
      end
c-----------------------------------------------------------------------
      subroutine userq  (ix,iy,iz,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'
C
      qvol   = 0.0
      source = 0.0

      return
      end
c-----------------------------------------------------------------------
      subroutine useric(ix,iy,iz,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'
C
      return
      end
c-----------------------------------------------------------------------
      subroutine userbc (ix,iy,iz,iside,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      ux=0.0
      uy=0.0
      uz=0.0
      temp=0.0

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat

      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'

      return
      end

c-----------------------------------------------------------------------
      subroutine usrdat2

      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'

      real pi
      real r,r0,z0,z1,z2,z3,z4,z5,dz

      n    = nx1*ny1*nz1*nelv

c     ifxyo= .true.

      xmin = glmin(xm1,n)
      xmax = glmax(xm1,n)
      ymin = glmin(ym1,n)
      ymax = glmax(ym1,n)
      zmin = glmin(zm1,n)
      zmax = glmax(zm1,n)

      if (IFNM) then
          nmscale = 1.e-9
          sx = nmscale            
          sy = nmscale                  
          sz = nmscale
          if (IF3D) sz = nmscale
      else
          nmscale = 1.0
          sx = nmscale
          sy = nmscale
          if (IF3D) sz = nmscale
      endif

      if (if3d) then

      do i=1,n
         xm1(i,1,1,1) = sx*xm1(i,1,1,1)
         ym1(i,1,1,1) = sy*ym1(i,1,1,1)
         zm1(i,1,1,1) = sz*zm1(i,1,1,1)
      enddo

      else

      do i=1,n
         xm1(i,1,1,1) = sx*xm1(i,1,1,1)       
         ym1(i,1,1,1) = sy*ym1(i,1,1,1)                
      enddo

      endif

      xmin = glmin(xm1,n)
      xmax = glmax(xm1,n)
      ymin = glmin(ym1,n)
      ymax = glmax(ym1,n)
      zmin = glmin(zm1,n)
      zmax = glmax(zm1,n)

      r0=257*nmscale ! EDITME
      dz=36*nmscale ! EDITME
      z0=0
      z1=944*nmscale ! EDITME 
      z2=z1+dz
      z3=1304*nmscale ! EDITME 
      z4=z3+dz
      z5=1780*nmscale ! EDITME 

      nxy2 = (nx1+1)/2

      do ie=1,nelv
         xmid = xm1(nxy2,nxy2,1,ie)
         ymid = ym1(nxy2,nxy2,1,ie)
         zmid = zm1(nxy2,nxy2,1,ie)
         rr = sqrt(xmid**2+ymid**2)
         
         if (zmid.le.z1) then
           if_in_region(ie)=1 ! substrate
         elseif (zmid.le.z2) then
           if (rr.le.r0) then
             if_in_region(ie)=2 ! gold
           else
             if_in_region(ie)=1 ! substrate
           endif
         elseif (zmid.le.z3) then
           if (rr.le.r0) then
             if_in_region(ie)=0 ! air
           else
             if_in_region(ie)=1 ! substrate
           endif
         elseif (zmid.le.z4) then
           if (rr.le.r0) then
             if_in_region(ie)=0 ! air
           else
             if_in_region(ie)=2 ! gold
           endif
         elseif (zmid.le.z5) then
           if_in_region(ie)=0 ! air
         else
           print *, 'zmid=', zmid, ' is invalid.'
           call exit
         endif
      enddo

      xmin = glmin(xm1,n)
      xmax = glmax(xm1,n)
      ymin = glmin(ym1,n)
      ymax = glmax(ym1,n)

      !write(6,*) 'xmin/xmax--',xmin,xmax,ymin,ymax
      !call exitt

      return
      end

c-----------------------------------------------------------------------
c This routine is called every time step by the solver
c-----------------------------------------------------------------------
      subroutine userchk
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'

      common /ccpu/ cpu_t,cpu_t0

c ... compute errors

      if (istep.le.10.or.mod(istep,iocomm).eq.0) then

        ntott = nx1*ny1*nz1*nelt
        nsrf  = nx1*nz1*nelt*6

        if (ifsol) then
          call usersol(time,shx,shy,shz,sex,sey,sez)
        else
          call rzero(shx, ntott) 
          call rzero(shy, ntott) 
          call rzero(shz, ntott) 
          call rzero(sex, ntott) 
          call rzero(sey, ntott) 
          call rzero(sez, ntott) 
        endif

        call sub3(ErrHX,SHX,HX,NTOTT) 
        call sub3(ErrHY,SHY,HY,NTOTT) 
        call sub3(ErrHZ,SHZ,HZ,NTOTT) 
        call sub3(ErrEX,SEX,EX,NTOTT) 
        call sub3(ErrEY,SEY,EY,NTOTT) 
        call sub3(ErrEZ,SEZ,EZ,NTOTT) 

        HXmr = glamax(ErrHX,NTOTT) 
        HYmr = glamax(ErrHY,NTOTT) 
        HZmr = glamax(ErrHZ,NTOTT) 
        EXmr = glamax(ErrEX,NTOTT) 
        EYmr = glamax(ErrEY,NTOTT) 
        EZmr = glamax(ErrEZ,NTOTT) 

        HXer = glsc3(ErrHX,bm1,ErrHX,NTOTT) / volvm1
        HYer = glsc3(ErrHY,bm1,ErrHY,NTOTT) / volvm1
        HZer = glsc3(ErrHZ,bm1,ErrHZ,NTOTT) / volvm1
        EXer = glsc3(ErrEX,bm1,ErrEX,NTOTT) / volvm1
        EYer = glsc3(ErrEY,bm1,ErrEY,NTOTT) / volvm1
        EZer = glsc3(ErrEZ,bm1,ErrEZ,NTOTT) / volvm1

        if (hxer.gt.0) hxer = sqrt(hxer)
        if (hyer.gt.0) hyer = sqrt(hyer)
        if (hzer.gt.0) hzer = sqrt(hzer)
        if (exer.gt.0) exer = sqrt(exer)
        if (eyer.gt.0) eyer = sqrt(eyer)
        if (ezer.gt.0) ezer = sqrt(ezer)


c ... compute max gap size at interfaces between elmts.

        call CEM_GAP                     

        HXgp = glamax(gHX,NSRF) 
        HYgp = glamax(gHY,NSRF) 
        HZgp = glamax(gHZ,NSRF) 
        EXgp = glamax(gEX,NSRF) 
        EYgp = glamax(gEY,NSRF) 
        EZgp = glamax(gEZ,NSRF) 

c ... print statement

        snel = nelt + .5
        snel = sqrt(snel)
        nels = snel
        nnn  = nx1-1
        npt1 = nnn*nels
        npts = nx1*ny1*nz1*nelt ! npts = npt1**ndim

        if (istep.eq.0)       cpu_p_t= 0
        if (istep.gt.0)       cpu_p_t= cpu_t/(npts*istep)
        if (istep.eq.nsteps)  cpu_p_t= glsum(cpu_p_t,1)/np

        if (nid.eq.0) then

          write(6,91) ISTEP,nelt,nels,nnn,npt1,npts
     $         ,time,dt,HXer,HYer,HZer,EXer,EYer,EZer,cpu_t,cpu_p_t
          write(6,95) ISTEP,nelt,nels,nnn,npt1,npts
     $         ,time,dt,HXmr,HYmr,HZmr,EXmr,EYmr,EZmr,cpu_t,cpu_p_t

 91       format(/,i9,3i5,i5,i9,1p9e10.3,e9.2,' CPU: L2  '  )
 95       format(  i9,3i5,i5,i9,1p9e10.3,e9.2,' CPU: Linf'  )

        endif ! nid=0

      endif

      call process_poynting

      return
      end

c-----------------------------------------------------------------------
      subroutine process_poynting
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'

      integer icalld
      save    icalld
      data    icalld /0/

      integer  e,f,nkey,iisum
      save     nkey,iisum
      common   /cpoynt/ flag(2*ldim,lelt)
      integer  flag
      real     usum, asum, zsum, zavg
      ! Variables to store total surface integrals over transmission
      ! surface for various field components
      real     tsi_ex, tsi_ey, tsi_ez
      real     tsi_hx, tsi_hy, tsi_hz
      real     tsi_sincex, tsi_sincey, tsi_sincez
      real     tsi_sinchx, tsi_sinchy, tsi_sinchz
      real     tsi_poytSx, tsi_poyiSx

      ! BEGIN ONE TIME INITIALIZATION
      if (icalld.eq.0) then  ! customize your selection here
        ! unflag all faces
        do e=1,nelv
          do f=1,2*ndim
            flag(f,e) = 0
          enddo
        enddo

        ! Here we find all #6 faces whose average z value lies
        ! between zz_0 and zz_1 and flag them
        nkey = 1 
        isum = 0 ! number of faces found
        f = 6    ! Faces labeled 6 are the upward pointing faces in a 3D mesh
        if (incflag.eq.1) then
          tsurface = 1580*nmscale 
        elseif (incflag.eq.-1) then
          tsurface = 200*nmscale 
        endif
        zz_0 = tsurface - 1.0e-14
        zz_1 = tsurface + 1.0e-14
        do e=1,nelv
          call fcsum2(zsum,asum,zm1,e,f)  ! f in prex notation
          if (asum.gt.0) zavg = zsum/asum
          if (zz_0.le.zavg.and.zavg.le.zz_1) then
            flag(f,e) = nkey
            isum = isum+1
          endif
        enddo
        iisum=iglsum(isum,1)
        if (nid.eq.0) write(6,*) '# transmission faces = ',iisum
        ! Quit if there were no faces flagged.
        if (iisum.eq.0) then
          if (nid.eq.0) write(6,*) 'Integration surface not correct.'
          call exitt
        endif
        icalld = 1
      endif
      ! END ONE TIME INITIALIZATION

      ! Calculate incident and total Poynting vectors at each mesh point
      n = nx1*ny1*nz1*nelt
      call vcross(poyiSx,poyiSy,poyiSz,
     $       sincex,sincey,sincez,sinchx,sinchy,sinchz,n)
      call vcross(poytSx,poytSy,poytSz,ex,ey,ez,hx,hy,hz,n)

      ! BEGIN CALCULATING SURFACE INTEGRALS
      ! Initialize surface integrals to zero
      tsi_ex = 0
      tsi_ey = 0
      tsi_ez = 0
      tsi_hx = 0
      tsi_hy = 0
      tsi_hz = 0
      tsi_sincex = 0
      tsi_sincey = 0
      tsi_sincez = 0
      tsi_sinchx = 0
      tsi_sinchy = 0
      tsi_sinchz = 0
      ! Now loop over all flagged faces.  Calculate the surface integral
      ! of each component over the face, and add it to the corresponding
      ! total surface integral variable.
      do e = 1,nelv
        do f = 1,2*ndim
          if(flag(f,e).eq.nkey) then 
            ! face f must be in prex notation
            call fcsum2(usum,asum,ex,e,f)
            tsi_ex = tsi_ex + usum
            call fcsum2(usum,asum,ey,e,f)
            tsi_ey = tsi_ey + usum
            call fcsum2(usum,asum,ez,e,f)
            tsi_ez = tsi_ez + usum
            call fcsum2(usum,asum,hx,e,f)
            tsi_hx = tsi_hx + usum
            call fcsum2(usum,asum,hy,e,f)
            tsi_hy = tsi_hy + usum
            call fcsum2(usum,asum,hz,e,f)
            tsi_hz = tsi_hz + usum
            call fcsum2(usum,asum,sincex,e,f)
            tsi_sincex = tsi_sincex + usum
            call fcsum2(usum,asum,sincey,e,f)
            tsi_sincey = tsi_sincey + usum
            call fcsum2(usum,asum,sincez,e,f)
            tsi_sincez = tsi_sincez + usum
            call fcsum2(usum,asum,sinchx,e,f)
            tsi_sinchx = tsi_sinchx + usum
            call fcsum2(usum,asum,sinchy,e,f)
            tsi_sinchy = tsi_sinchy + usum
            call fcsum2(usum,asum,sinchz,e,f)
            tsi_sinchz = tsi_sinchz + usum
            call fcsum2(usum,asum,poyiSx,e,f)
            tsi_poyiSx = tsi_poyiSx + usum
            call fcsum2(usum,asum,poytSx,e,f)
            tsi_poytSx = tsi_poytSx + usum
          endif
        enddo
      enddo
      ! END CALCULATING SURFACE INTEGRALS

      ! Sum results from different processors via glsum
      tsi_ex=glsum(tsi_ex,1)
      tsi_ey=glsum(tsi_ey,1)
      tsi_ez=glsum(tsi_ez,1)
      tsi_hx=glsum(tsi_hx,1)
      tsi_hy=glsum(tsi_hy,1)
      tsi_hz=glsum(tsi_hz,1)
      tsi_sincex=glsum(tsi_sincex,1)
      tsi_sincey=glsum(tsi_sincey,1)
      tsi_sincez=glsum(tsi_sincez,1)
      tsi_sinchx=glsum(tsi_sinchx,1)
      tsi_sinchy=glsum(tsi_sinchy,1)
      tsi_sinchz=glsum(tsi_sinchz,1)

      if (param(70).eq.1) then
        call trans_calculation_feq(
     $    tsi_ex, tsi_ey, tsi_ez,
     $    tsi_hx, tsi_hy, tsi_hz,
     $    tsi_sincex, tsi_sincey, tsi_sincez,
     $    tsi_sinchx, tsi_sinchy, tsi_sinchz)
      endif

      return
      end
c-----------------------------------------------------------------------
c This subroutine calculates the transmission coefficient by Fourier
c transforming to the frequency domain the components of the
c time-dependent surface integral of the poynting vector components.
c The Fourier transform is computed over numerous wavelengths, as
c specified in the .rea file in parameters 42, 43, and 44.
c-----------------------------------------------------------------------
      subroutine trans_calculation_feq(
     $   tsi_ex, tsi_ey, tsi_ez,
     $   tsi_hx, tsi_hy, tsi_hz,
     $   tsi_sincex, tsi_sincey, tsi_sincez,
     $   tsi_sinchx, tsi_sinchy, tsi_sinchz)
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      integer   n_rows,max_nw, icalld
      parameter (max_nw=1000)
      integer   nw  ! number of wavelengths
      real      w_fst,w_lst,dw  ! first and last wavelengths and spacing between them
      real      w_vec(max_nw), om_vec(max_nw)
      real      tmpx, tmpy, tmpz
      save      icalld,w_fst,w_lst,dw,nw
      data      icalld/0/
      complex cplxi, cc
      parameter (cplxi=(0.d0,1.d0))
      complex trans_ex(max_nw), trans_ey(max_nw), trans_ez(max_nw)
      complex trans_hx(max_nw), trans_hy(max_nw), trans_hz(max_nw)
      complex trans_sincex(max_nw), trans_sincey(max_nw)
      complex trans_sincez(max_nw)
      complex trans_sinchx(max_nw), trans_sinchy(max_nw)
      complex trans_sinchz(max_nw)
      real       trans_sx(max_nw), trans_sy(max_nw), trans_sz(max_nw)
      real       trans_sincsx(max_nw), trans_sincsy(max_nw)
      real       trans_sincsz(max_nw)
      common /tranfeq/ trans_ex, trans_ey
     $               , trans_ez, trans_hx
     $               , trans_hy, trans_hz
     $               , trans_sincex, trans_sincey
     $               , trans_sincez, trans_sinchx
     $               , trans_sinchy, trans_sinchz
     $               , trans_sx, trans_sy
     $               , trans_sz, trans_sincsx
     $               , trans_sincsy, trans_sincsz
     $               , w_vec, om_vec
     
c     BEGIN ONE TIME INITIALIZATION
      if (icalld.eq.0) then 
        call czero(trans_ex,nw)
        call czero(trans_ey,nw)
        call czero(trans_ez,nw)
        call czero(trans_hx,nw)
        call czero(trans_hy,nw)
        call czero(trans_hz,nw)
        call czero(trans_sincex,nw)
        call czero(trans_sincey,nw)
        call czero(trans_sincez,nw)
        call czero(trans_sinchx,nw)
        call czero(trans_sinchy,nw)
        call czero(trans_sinchz,nw)
        call rzero(trans_sx,nw)
        call rzero(trans_sy,nw)
        call rzero(trans_sz,nw)
        call rzero(trans_sincsx,nw)
        call rzero(trans_sincsy,nw)
        call rzero(trans_sincsz,nw)
        call rzero(w_vec,max_nw)
        call rzero(om_vec,max_nw)
        ! Setup Fourier transform wavelengths and frequencies from the .rea file
        w_fst = param(42)
        w_lst = param(43)
        nw = param(44)
        if (nid.eq.0) write(6,*) 'w_fst,w_lst,nw=', w_fst, w_lst, nw
        if (w_lst.lt.w_fst.or.w_fst.le.0) then
          if (nid.eq.0) write(6,*) 'Must have 0<param(42)<=param(43)'
          call exitt
        endif
        if (nw.ne.1) then
          dw = (w_lst-w_fst)/(nw-1)
        else
          dw = 0
        endif
        if ((nw.gt.max_nw).or.(nw.le.0)) then
          if (nid.eq.0) write(6,*) 'Must have 0 < param(44) <= ', max_nw
          call exitt
        endif
        do i=1,nw
          w_vec(i)=w_fst+(i-1)*dw         ! wavelength
          om_vec(i)=2*pi*cspeed/w_vec(i)  ! angular frequency is 2*pi*speed/wavelength
          if (nid.eq.0) write(6,*) 'w_vec(', i, ') = ', w_vec(i)
        enddo
        icalld = 1
      endif
c     END ONE TIME INITIALIZATION

      do i=1,nw  
        cc = cexp(cplxi*om_vec(i)*time)*dt  
        trans_ex(i) = trans_ex(i) + cc*tsi_ex
        trans_ey(i) = trans_ey(i) + cc*tsi_ey
        trans_ez(i) = trans_ez(i) + cc*tsi_ez
        trans_hx(i) = trans_hx(i) + cc*tsi_hx
        trans_hy(i) = trans_hy(i) + cc*tsi_hy
        trans_hz(i) = trans_hz(i) + cc*tsi_hz
        trans_sincex(i) = trans_sincex(i) + cc*tsi_sincex
        trans_sincey(i) = trans_sincey(i) + cc*tsi_sincey
        trans_sincez(i) = trans_sincez(i) + cc*tsi_sincez
        trans_sinchx(i) = trans_sinchx(i) + cc*tsi_sinchx
        trans_sinchy(i) = trans_sinchy(i) + cc*tsi_sinchy
        trans_sinchz(i) = trans_sinchz(i) + cc*tsi_sinchz
      enddo

      ! On the last time step of the solver, calculate the time average
      ! Poynting vectors and write them to a file.  I'm taking advantage
      ! of the fact that the source E and H fields have the same phase.
      ! Under this hypothesis, S=(1/2)Re(E*Hconjugate).  See Griffiths'
      ! Introduction to Electrodynamics, 3rd Ed., p.382 (exercise 9.11)

      if ((mod(istep,iostep).eq.0).or.(istep.eq.nsteps)) then
      
       do i=1,nw
        trans_sx(i) = 0.5*dreal(
     $    trans_ey(i)*conjg(trans_hz(i))-trans_ez(i)*conjg(trans_hy(i)))
        trans_sy(i) = 0.5*dreal(
     $    trans_ez(i)*conjg(trans_hx(i))-trans_ex(i)*conjg(trans_hz(i)))
        trans_sz(i) = 0.5*dreal(
     $    trans_ex(i)*conjg(trans_hy(i))-trans_ey(i)*conjg(trans_hx(i)))
        trans_sincsx(i) = 0.5*dreal(
     $    trans_sincey(i)*conjg(trans_sinchz(i))
     $   -trans_sincez(i)*conjg(trans_sinchy(i)))
        trans_sincsy(i) = 0.5*dreal(
     $    trans_sincez(i)*conjg(trans_sinchx(i))
     $   -trans_sincex(i)*conjg(trans_sinchz(i)))
        trans_sincsz(i) = 0.5*dreal(
     $    trans_sincex(i)*conjg(trans_sinchy(i))
     $   -trans_sincey(i)*conjg(trans_sinchx(i)))
        ! Dependending on the direction of the incident field, it
        ! happens that one or more of trans_sincsx, trans_sincsy, and
        ! trans_sincsz will be zero.  Thus we cannot calculate the
        ! transmission ratio (of total to incident Poynting component)
        ! in these cases, because we'll be dividing by zero.
        ! Therfore, if any of these are zero, set them to 1e300,
        ! which makes the corresponding ratio effectively zero but avoids
        ! floating point exceptions.
        tmpx = trans_sincsx(i)
        tmpy = trans_sincsy(i)
        tmpz = trans_sincsz(i)
        if (tmpx.eq.0) tmpx = 1.e300
        if (tmpy.eq.0) tmpy = 1.e300
        if (tmpz.eq.0) tmpz = 1.e300

        if (nid.eq.0) then
          write( 6,4) w_vec(i), trans_sx(i), trans_sy(i), trans_sz(i),
     $    trans_sincsx(i), trans_sincsy(i), trans_sincsz(i),
     $    trans_sx(i)/tmpx,  ! X component of transmission ratio
     $    trans_sy(i)/tmpy,  ! Y component of transmission ratio
     $    trans_sz(i)/tmpz   ! Z component of transmission ratio
        endif

        if ((nid.eq.0).and.(istep.eq.nsteps)) then
          write(34,4) w_vec(i), trans_sx(i), trans_sy(i), trans_sz(i),
     $    trans_sincsx(i), trans_sincsy(i), trans_sincsz(i),
     $    trans_sx(i)/tmpx,  ! X component of transmission ratio
     $    trans_sy(i)/tmpy,  ! Y component of transmission ratio
     $    trans_sz(i)/tmpz   ! Z component of transmission ratio
        endif

       enddo
      endif
    4 format(e13.5,9e20.10)

      return
      end

c-----------------------------------------------------------------------
c The czero function zeros out a vector ww of length n containing
c single precision complex numbers
c-----------------------------------------------------------------------
      subroutine czero(ww, n)
      complex ww
      dimension ww(1)
      do i=1,n
        ww(i)=(0.d0,0.d0)
      enddo
      return
      end
