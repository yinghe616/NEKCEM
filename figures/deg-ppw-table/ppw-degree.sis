from __future__ import division
import math

ROUNDTRIPS = 10

rea_switches = {
  "ifcentral": False, "ifupwind": True, "ifdealias": False
  }

def gcd(q, r):
    """Return a tuple (p, a, b) such that p = aq + br, 
    where p is the greatest common divisor.
    """

    if abs(q) < abs(r):
        return gcd(r, q)
  
    Q = 1, 0
    R = 0, 1
  
    while r:
        quot, t = divmod(q, r)
        T = Q[0] - quot*R[0], Q[1] - quot*R[1]
        q, r = r, t
        Q, R = R, T
  
    return q




for degree in [4,8,12,16]:
    for ppw in [4,6,8,12,16,24,32]:
        my_gcd = gcd(ppw, degree)
        n_elements = ppw/my_gcd
        # "lwaves" means "longitudinal waves"
        lwaves = degree/my_gcd

        while n_elements <= 2:
            n_elements *= 2
            lwaves *= 2

        assert ppw == float(degree)*n_elements/lwaves
        #print "ppw:%d n:%d lw:%d deg:%d" % (ppw, n_elements, lwaves, degree)
        #continue

        for dt_div_power in range(0,7):
            dt = 1e-1/(2**dt_div_power)
            points = n_elements * (degree+1)

            boxres = (n_elements, n_elements)

            steps = ROUNDTRIPS/dt
            test_error("examples/2dboxppec", "2dboxppec", "2dboxppec",
                    max_error=None, degree=degree,
                    rea_parameters={"usrres1": lwaves, "iocomm": steps},
                    rea_switches=rea_switches,
                    at_timestep=steps, dt=dt,
                    boxres=boxres)

